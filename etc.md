 ## [뒤로](#기타)
 # 공부해보면 좋을 부분

 # C 언어를 사용한 객체-지향 프로그래밍:
 알다시피 C 언어는 명령형 프로그래밍 언어이고, 
 객체-지향 프로그래밍 언어가 필수적으로 갖추어야 할 
 ‘추상 데이터 타입(ADT)’, ‘상속’, ‘다 형성’ 등의 기능을 제공하지 않습니다. 
 그러나 C 언어의 다양한 프로그래밍 기법을 이용하 여 어설프게나마 객체-지향 프로그래밍과 유사하게 프로그램을 작성할 수 있습니다. 
 어떻게 하면 될까요? 이것을 공부하면 여러분의 C 프로그래밍과 객체-지향에 대한 이해가 깊어질 것입니다.
 
 # 객체-지향 언어들의 다중상속 비교:
 다중상속(multiple inheritance)은 객체-지향 프로그래밍 언어에서 ‘뜨거운 감자’와 같은 주제입니다. 
 필요할 때가 분명히 있음에도 불구하고, 그것의 도입으로 인해 야기되는 여러 가지 문제점들이 있기 때문입니다. 
 각 객체-지향 언어들마다 다중상속 문제에 대응하는 방식은 차이가 있으며, 그에 대한 논리도 있습니다. 
 몇 가지 주 요 객체-지향 언어들의 다중상속 방식을 꼼꼼히 비교해 보는 일은 여러분의 객체-지향에 대 한 이해를 심화시키는 효과를 가져 올 것입니다.
 
 # 프로그래밍 언어의 정형적 의미론 중 공리적 의미론 고찰: 
 보다 중요한 응용 분야에 컴퓨터 가 사용됨에 따라 신뢰성(reliability) 높은 소프트웨어 제작에 대한 요구는 점점 더 높아지 고 있습니다. 
 신뢰성 높은 소프트웨어, 즉 버그(bug) 없이 명세(specification)와 일치하는 소프트웨어를 작성하거나 검증하기 위해서는 
 구현 언어의 의미론(semantics)이 명확하게 정의 되어 있어야 합니다. 
 이런 뜻에서 프로그래밍 언어의 정형적 의미론(formal semantics)은 여 전히 관심을 받고 있습니다.
 주요 정형적 의미론 중 하나를 학부생 수준에서 공부해 보는 것은 의미 있는 일이 될 것입니다.
 
 # 알고리즘/계산이론 분야
 
 ## 이진 탐색(binary search)의 분할 위치에 따른 성능 비교: 
 일반적인 이진 탐색은 탐색해야 할 군집 데이터의 정 가운데 항목과 찾으려고 하는 키(key)를 비교합니다. 
 그 비교의 결과 항목을 찾거나, 아니면 앞의 반 또는 뒤의 반을 탐색 공간에서 제외시키게 되죠. 
 만약 군집 데이터의 정 가운데가 아닌 위치(예컨대 앞에서 ⅓ 위치)의 항목과 키를 비교하면 어떨까요? 
 그 비교의 결과 항목을 찾거나, 아니면 앞의 ⅓ 또는 뒤의 ⅔를 탐색 공간에서 제외시키게 되겠죠. 
 어떤 게 효율적일까요? 무작위하게 만든 샘플 데이터에 대해 여러 번 수행시 켜 평균치를 구하면 의미 있는 결과를 구할 수 있을 겁니다. 
 
 ## P와 NP 문제의 역사와 정의: 
 보통 학부 과정에서는 ‘계산이론’이나 ‘형식언어’, ‘오토마타’같 은 과목이 개설되더라도 P와 NP 문제를 깊이 다루지는 않습니다.
 P와 NP의 관계는 현재 이론 컴퓨터/정보 과학에서 가장 중요한 문제입니다. 
 이 주제에 대해 그 역사적 배경을 살 펴보고 지금 도달해 있는 상태를 요약해 보는 일은 재미도 있고 차별화시켜보기.
 
 ## '여행하는 세일즈맨 문제(Traveling Salesperson Problem; TSP)’에 대한 다양한 해법: 
 TSP 문제는 오래된 대표적 NP 문제입니다. 이 문제에 대한 다양한 접근법이 존재합니다. 
 정통 적인 알고리즘적 기법(탐욕적 방법이나 분기한정법 등)뿐만 아니라 인공지능 기법을 이용한 접근방법도 있습니다. 
 따라서 이 단일 문제만으로 한정하더라도 배우는 게 제법 있을 것입 니다. 
 
 ## ‘최소 신장 트리(Minimum Spanning Tree)’ 
 알고리즘들의 최적화를 위한 자료구조: 
 Prim이 나 Kruskal 알고리즘의 효율성을 조금 더 높이기 위해 특이한 자료구조를 사용하는 방법이 있습니다. 
 알고리즘 수업을 들은 학생들은 해당 절의 마지막 부분에 참고문헌을 적시하며 간단하게 언급하는 것을 본 기억이 어쩌면 있을 지도 모르겠습니다. 
 최소 신장 트리뿐만 아 니라 다른 문제의 경우에도 비슷한 접근방법이 공통적으로 나타납니다. 
 그 중 한 문제를 골 라서 최근까지의 성과를 살펴보는 것입니다.
 
 # 데이터베이스 분야
 다양한 데이터베이스 정규형(Normal Form)과 그 의미: 
 여러분은 데이터베이스 시간에 여러 가지 데이터베이스 정규형(제1 정규형, 제2 정규형, Boyce-Codd 정규형 등)을 배웠을 것입 니다. 
 아마 학부 수업시간에는 지금까지 등장한 모든 데이터베이스 정규형을 다루지 않았을 것이라고 짐작합니다. 
 수업시간에 다루지 않은 정규형들을 포함하여, 정규형을 정의하고 그 목적과 예제, 장단점 비교, 실제 구현에서의 문제점 등을 살펴보는 것입니다.
 
 
 # 운영체제 분야
 실험을 통한 페이지 대체 알고리즘의 효율성 비교: 
 여러분은 수업 시간에 여러 가지 페이지 대체(page replacement) 알고리즘을 학습했습니다. 예
 를 들어, FIFO(First-In First-Out)이나 LRU(Least Recently Used)같은 것 말이죠.
 또한 LRU가 효율적이라는 결론만 들었을 가능 성이 높습니다. 
 그리 복잡하지 않은 프로그램으로 과연 LRU가 정말 효율적인지를 시뮬레이션  
